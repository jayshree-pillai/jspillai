# PromptBundle : The exact payload to send to the LLM
from typing import List, Optional
from pydantic import BaseModel

class Message(BaseModel):
    role: str          # "system" | "user" | "assistant"
    content: str

class PromptBundle(BaseModel):
    section: str
    version: str
    component_id: str
    step: str          # "extract" | "compose" | "verify"

    messages: List[Message]
    retrieval_profile: Optional[str] = None
    kpi_pack: Optional[str] = None
----------
# GateResult : quality check for the LLM response
from typing import List, Optional
from pydantic import BaseModel


class GateResult(BaseModel):
    status: str # "PASS" | "WARN" | "FAIL"
    reasons: List[str] = []
    action: Optional[str] = None   # e.g., "RUN_VERIFY" | "RETRY" | None
-----------
# PromptPlan : compiled plan contract that compile.py will output and execute.py will consume.
from typing import Any, Dict, List, Optional
from pydantic import BaseModel


class ComponentOverride(BaseModel):
    retrieval_profile: Optional[str] = None
    kpi_pack: Optional[str] = None
    risk_level: Optional[str] = None
    steps: Optional[List[str]] = None
    gates: Optional[List[str]] = None


class ComponentPlan(BaseModel):
    component_id: str
    override: Optional[ComponentOverride] = None


class PromptPlan(BaseModel):
    section: str
    version: str
    components: List[ComponentPlan]
    meta: Dict[str, Any] = {}
---------------
# Evidence/citation mapping citation map linking each claim/field to the evidence chunk IDs that support it
from typing import Dict, List
from pydantic import BaseModel


class Provenance(BaseModel):
    # claim/field - list of chunk ids
    citations: Dict[str, List[str]] = {}
---------------
# Results:LLM produced per step/content and final stitched section narrative + gates + citiations
from typing import Any, Dict, Optional
from pydantic import BaseModel
from .gate import GateResult
from .provenance import Provenance

class StepResult(BaseModel):
    text: str
    data: Optional[Dict[str, Any]] = None          # e.g., extracted facts_json
    provenance: Provenance = Provenance()
    gate: GateResult = GateResult(status="PASS")

class ComponentResult(BaseModel):
    component_id: str
    extract: Optional[StepResult] = None
    compose: Optional[StepResult] = None
    verify: Optional[StepResult] = None

class SectionResult(BaseModel):
    section: str
    version: str
    narrative: str                                 # stitched section text
    components: Dict[str, ComponentResult] = {}
